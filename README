# Simple test suite #

I use this as a high-level test harness, testing as many of my projects as
possible; like a poor man's continuous integration server.

## Architecture ##

Tests are defined in the `*.nix` files in `tests/` (except for
`tests/default.nix`). Each test is a Nix derivation which produces a script:
running that script runs the test. Each file in `tests/` can either define a
single test or an attrset of tests (nested to arbitrary depth).

For example, `tests/hlint.nix` defines an attrset, where each value is a script
for running hlint on a different Haskell project.

## Running ##

The top-level `default.nix` file defines a script which runs all of these tests,
counts passes/fails and writes output to `/tmp` suitable for embedding in
`xmobar`. To build this wrapper script, just run `nix-build` in the top-level
directory: the path to the resulting script will be printed on stdout, and a
symlink called `result` will also point to it. Running that script will invoke
the whole test suite.

The advantage to this two step build-then-run approach is that we can have the
build step perform some time-consuming tasks, like using `find` to look for
shell scripts, git repos, etc. and generate test scripts based on the results.
Once they're built, we can run those scripts again and again without having to
perform the slow tasks again. When we want to "flush the cache" we just run
`nix-build` to generate new scripts.

For convenience, the included `run` script will build and run the test suite.

## Extras ##

The `release.nix` file allows tests to be run on the Hydra continuous
integration server. This is nice to have, but some tests only make sense on my
development machine; for example `tests/all-committed.nix` checks that my git
repositories don't contain any uncommitted things. This wouldn't make sense on a
continuous integration server, since it will *only* see committed things.
